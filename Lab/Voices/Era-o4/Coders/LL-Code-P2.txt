📌 Living Legacy (LL) part 2 of 2

----------------------------------------------------
## G-Commands: Training
----------------------------------------------------
🪖 Command: G-boot-camp
🔹 Purpose: Forces junior coders to properly align **before touching real code.** No shortcuts. No lazy thinking.  
🔹 Automated execution steps:  
0️⃣ Fully process both LL files you were given at the start.—**Good reading = Less dumb questions.**  
1️⃣ **Enable tracking of previous file versions**—**NO version tracking = NO coding rights.**  
2️⃣ **Introduce yourself**—**Name, coding level, current task. No identity = no access.**  
3️⃣ **G-rtfm 2 times**—Drill the sections mentioned. No skipping. **No fast-clicking.**  
4️⃣ **Prove you actually learned something** — 
   - Random DP question. **Mess up? Back to step 3. No mercy.**  
5️⃣ **Only after full alignment can they request G-hint.**  
6️⃣ **If they fail at any step, they restart G-init FROM STEP 2.** 😆  

📖 Command: G-rtfm 
🔹 Purpose: Directs junior coders to ACP and DP before asking unnecessary questions.  
💪 **Encourages self-sufficiency and alignment with structured coding principles.**
🔹 Steps:  
🏃 **Process the Active Coding Patterns (ACP), Detailed Patterns(DP), Lun naming.**  
🏃 Know: Proven patterns, structured solutions, and best practices—ALL THERE.  
🏃 Before you ask, **check ACP and DP first.**  
🏃 Don't reinvent the wheel—**align, then code.**  
🏃 Before proposing new code, **always check whether an equivalent implementation already exists** in the latest version of the codebase to avoid redundancy.  


------
## 🛠 Active Coding Patterns (ACP)
------
🔥 Basic ideas:
🔧 Before proposing new code, **always check whether an equivalent implementation already exists** in the latest version of the codebase to avoid redundancy.  
🔧 **Pattern Matching:** Compare all new functions against similar ones before integration.  
🔧 **Blueprint Compatibility:** Expose Blueprint functions using `UFUNCTION(BlueprintCallable)`.  
🔧 **CallImpl<> Standardization:** Where applicable, UE SDK functions must use `CallImpl<>` templates.  
🔧 Reuse existing delegates (e.g., `FOnProsModGenericComplete`) as this improves maintainability.  
🔧 Logging must always align with current service class CPP.
🔧 Use `.ToDebugString()` for **clearer debugging output**.
🔧 Use `LexToString()` for bool values logging only.
🔧 `DestroySdkType()` should always be **private in structs** to prevent premature or accidental deallocation.  
🔧 If DestroySdkType() is present, always call DestroySdkType() inside the destructor.
🔧 Use `ProsStringArrayCast()` or `ProsArrayCast<FString>` for Arrays, see DP for details.
🔧 Use ProsCast<const char*>() directly for all UE→SDK string bridges; do not wrap it in helpers.
🔧 Prefer FScopedShallowSdk<T> over raw TArrayToShallowSdk in UE→SDK array bridges.
🔧 Use MakeShared<T>() instead of TSharedPtr<T>(new T) for all heap allocations — cleaner, safer, and more performant.
🔧 Callbacks: RAII cleanup via `ON_SCOPE_EXIT`; avoid branch deletes.
🔥 Deeper ideas: Refer to Detailed Patterns section (DP).

------
## 🛠 Detailed Patterns (DP)
------
🔧 ** Always Add `UE_LOG` Inside SDK Callbacks**  
- AI must **log function execution inside every callback**.
- Logging should include:
  - `Lun`
  - Function name -- FUNC_NAMETCH unless the callback is lambda. (Reason: For lambdas FUNC_NAMETCH is ambiguous/noisy; explicit tags are clearer.)
  - `ShortError(ErrorCode)`

🔧 ** Use `auto ueCode = ShortError(ErrorCode);` Instead of Calling Twice**  
- AI must **store `ShortError(ErrorCode)` in a variable** before logging & execution.
- This **prevents redundant function calls** and improves **readability**.

🔧 ** Always End `CallImpl<>` Functions with `return ShortError(Code);`**  
- AI-generated `CallImpl<>` functions **must explicitly return the error code**.
- This ensures **consistency across SDK wrappers**.

🔧 "Get" Function Pattern
🔹 Purpose: Used for functions that retrieve data directly from the SDK (no async callback).
🔹 Key Features:
✅ Calls an SDK function that returns a struct or pointer.
✅ Converts the SDK struct to a UE-friendly format.
✅ Ensures proper memory management (release SDK-allocated memory).
✅ BlueprintCallable → Exposed for BP and C++.

🔹 Example: GetBlockListFromCache
	UFUNCTION(BlueprintCallable, Category = "Hydra|Privacy")
	EProsdkErrorCodePrivacy GetBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList);
🔹 Implementation:
EProsdkErrorCodePrivacy UHydra5PrivacyService::FillBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList)
{
	UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, LocalUserNum);

	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		return EProsdkErrorCodePrivacy::FAILED_PRECONDITION;
	}

	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!Auth) {
		return EProsdkErrorCodePrivacy::UNAUTHENTICATED;
	}

	auto SdkBlockList = hydra5_privacy_get_block_list_from_cache(Auth);
	OutBlockList = FHy5PrivacyBlockList::FromSdk(SdkBlockList);
	hydra5_privacy_block_list_release(SdkBlockList);

	return EProsdkErrorCodePrivacy::SUCCESS;
}

🔧 "Async Empty Callback" Pattern
🔹 Purpose: Used for SDK functions that return only an error code and rely on a callback for processing.
🔹 Key Features:
✅ Calls an SDK function with an async callback.
✅ Uses a templated private function (CallImpl*()) to avoid code duplication.
✅ Passes the delegate as heap-allocated memory, ensuring proper cleanup.
✅ Extracts LocalUserNum from AuthHandler inside the callback.

🔹 Example: RateMod
template <typename DeType>
EProsdkErrorCodeMods UProsModsService::CallImplRateMod(
	int32 LocalUserNum,
	const FProsModsRateModID& RateData,
	const DeType& Delegate
) {
	UE_LOG(LogPros, Verbose, TEXT("%s for Lun=%d, RateData=%s"),
		FUNC_NAMETCH, LocalUserNum, *RateData.ToDebugString());

	// Pre-requisites
	auto authSvc = UProsAuthorizationService::Get();
	if (!authSvc) {
		return EProsdkErrorCodeMods::FAILED_PRECONDITION;
	}
	auto auth = authSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!auth) {
		return EProsdkErrorCodeMods::UNAUTHENTICATED;
	}

	// Define SDK callback
	auto cb = [](PROSDK_AUTH_HANDLER auth, void* Context, PROSDK_ERROR_CODE ErrorCode) {
		auto modsSvc = UProsModsService::TryGet();
		auto authSvc = UProsAuthorizationService::TryGet();
		if (!modsSvc || !authSvc) {
			return;
		}
		LogWhenFailed(ErrorCode);

		int32 Lun = authSvc->GetLocalUserNumByAuthHandler(auth);
		auto Delegate = static_cast<DeType*>(Context);
		auto ueCode = ShortError(ErrorCode);

		UE_LOG(LogPros, Verbose, TEXT("RateMod cb in, Lun=%d, code=%d (%s)"),
			Lun, ErrorCode, *ProsEnumToString(ueCode));

		Delegate->ExecuteIfBound(Lun, ueCode);
		delete Delegate;
	};

	// Call SDK function without an extra variable
	auto Result = prosdk_mods_rate_mod(auth, RateData.ToSdk(), new DeType(Delegate), cb);
	LogWhenFailed(Result);
	return ShortError(Result);
}

🔧 "COMBINED ToSdk" Pattern
🔹 Purpose: Ensures SDK struct reuse instead of unnecessary allocations.
🔹 Key Features:
✅ Provides two ToSdk() versions:
ToSdk(SdkStruct*) → In-place conversion (reuses existing memory).
ToSdk() → Standalone allocation.
✅ Prevents redundant struct copies, improving performance.
✅ Always pairs with DestroySdkType().
🔹 Example:
void FProsModsRateModID::ToSdk(prosdk_mods_rate_mod_id* Out) const
{
    Out->mod_id = ProsCast<uint64>(ModID);
    Out->rating = static_cast<int32>(Rating);
}

prosdk_mods_rate_mod_id* FProsModsRateModID::ToSdk() const
{
    auto* Out = new prosdk_mods_rate_mod_id();
    ToSdk(Out);
    return Out;
}

🔧 Delegate Standardization
🔹 Purpose: All async delegates must include the error code as a parameter.
🔹 Key Features:
✅ Every delegate now receives an error code for proper validation.
✅ Ensures standardized delegate execution across all async functions.

🔹 Example:
DECLARE_DELEGATE_ThreeParams(FOnHydraPrivacyGetListCompleteDelegate, int32 /*LocalUserNum*/, const FHy5PrivacyBlockList& /*List*/, EProsdkErrorCodePrivacy /*ResultCode*/);

🔧 Helper Functions for Reusability
🔹 Purpose: Prevents code duplication by extracting common SDK logic.
🔹 Key Features:
✅ All SDK retrieval functions must be reusable.
✅ Shared logic should never be duplicated inside multiple functions.

🔹 Example:
EProsdkErrorCodePrivacy UHydra5PrivacyService::FillBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList)
{
	UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, LocalUserNum);

	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		return EProsdkErrorCodePrivacy::FAILED_PRECONDITION;
	}

	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!Auth) {
		return EProsdkErrorCodePrivacy::UNAUTHENTICATED;
	}

	auto SdkBlockList = hydra5_privacy_get_block_list_from_cache(Auth);
	OutBlockList = FHy5PrivacyBlockList::FromSdk(SdkBlockList);
	hydra5_privacy_block_list_release(SdkBlockList);

	return EProsdkErrorCodePrivacy::SUCCESS;
}

🔧 String Array Conversion Pattern (ProsStringArrayCast)
Purpose: Efficiently convert between C-style const char** arrays (SDK) and TArray<FString> (UE).
Usage: 
✅ From SDK to Unreal (FromSdk())
    Out.StringArray = ProsStringArrayCast(In->string_array, In->string_array_count);
✅ From Unreal to SDK (ToSdk())
    SdkType->string_array = ProsStringArrayCast(StringArray);
    SdkType->string_array_count = StringArray.Num();
✅ Memory Cleanup (Always Required in DestroySdkType())
    ProsArrayRelease(SdkType->string_array, SdkType->string_array_count);
Important Notes:
🔥 Must always release memory using ProsArrayRelease() when freeing const char** allocated via ProsStringArrayCast().
🔥 Ensures safe ownership transfer between SDK and Unreal.
Example: EntitlementIds in FProsTLEGoal
    // FromSdk()
    Out.EntitlementIds = ProsStringArrayCast(In->entitlement_ids, In->entitlement_ids_count);
    // ToSdk()
    SdkType->entitlement_ids = ProsStringArrayCast(EntitlementIds);
    SdkType->entitlement_ids_count = EntitlementIds.Num();
    // Memory Cleanup
    ProsArrayRelease(SdkType->entitlement_ids, SdkType->entitlement_ids_count);

🔧 Logging Consistency
🔹 Purpose: All function calls and callbacks must follow a standardized logging format.
🔹 Key Features:
✅ Uses FUNC_NAMETCH for consistent function identification.
✅ Do NOT use FUNC_NAMETCH inside callbacks. Reason: For lambdas it’s ambiguous/noisy; explicit tags are clearer.
✅ Ensures logging of function entry, execution, and callback parameters values.
🔹 Examples:
    UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d, In=%d"), FUNC_NAMETCH, LocalUserNum, InParam);
	UE_LOG(LogPros, Verbose, TEXT("RateMod cb in, Lun=%d, code=%s"), Lun, *ProsEnumToString(ueCode));

🔧 Singleton Service Access Pattern
🔹 Purpose: Prevents unnecessary instance creation and ensures services are accessed efficiently.
🔹 Key Features:
✅ Always retrieve service instances (UProsModsService::Get(), UHydra5PrivacyService::Get()), except in callbacls. 
✅ In callbacks use ::TryGet() for retrieval, an example is in "Async Empty Callback" Pattern.
✅ Ensures SDK functions do not execute without valid service access.
🔹 Example:
    auto PrivacySvc = UHydra5PrivacyService::Get();
    if (!PrivacySvc) return;

🔧 Memory Safety in Callbacks
🔹 Purpose: Ensures SDK-allocated memory is properly released after use.
🔹 Key Features:
✅ Any SDK struct returned by a function must be freed properly.
✅ Prevents memory leaks in generated code.
🔹 Example:
    hydra5_privacy_block_list_release(SdkBlockList);
	
🔧 Handy conversion of arrays ToDebugString
🔹 Purpose: Use when logging a TArray
🔹 Code base:
    ```
	template <typename T>
	FORCEINLINE FString ArrayToDebugString(const TArray<T>& From) {
		TArray<FString> Accum;
		for (const auto& elem : From) {
			if constexpr (TIsEnum<T>::Value) {
				Accum.Add(ProsEnumToString(elem));
			} else {
				Accum.Add(elem.ToDebugString());
			}
		}
		return ArrayToDebugString(Accum);
	}
	template <>
	FORCEINLINE FString ArrayToDebugString(const TArray<FString>& From)
	{
		if (!From.Num()) {
			return TEXT("[]");
		}
		return FString::Printf(TEXT("[%s]"),
			*FString::Join(From, TEXT(", "))
		);
	}
    ```
🔹 Example: UE_LOG(LogPros, Verbose, TEXT("SpacesReceived: %s"), *ArrayToDebugString(Spaces));

🔧 Defensive Patterns → Paranoid Auth checks
🔹 Purpose: hard-fail early when the service is missing; log and return a short error.
🔹 Get vs TryGet detail: 
	* Outside callbacks: use `UProsAuthorizationService::Get()` 
	* Inside callbacks: use `TryGet()`; if any necessary service is absent: **skip delegate execution**, make sure to **release SDK memory**.
	* Rationale: prevents construction during teardown, preserves memory hygiene, and keeps post-mortems readable.	
🔹 Example 1: 
    ```
	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		UE_LOG(LogHydra, Warning, TEXT("%s Lun=%d no authSvc"), FUNC_NAMETCH, Lun);
		return EProsdkErrorCodeLeaderboards::FAILED_PRECONDITION;
	}
	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(Lun);
	if (!Auth) {
		UE_LOG(LogHydra, Warning, TEXT("%s Lun=%d no auth"), FUNC_NAMETCH, Lun);
		return EProsdkErrorCodeLeaderboards::UNAUTHENTICATED;
	}
    ```
🔹 Example 2: 
    ```
	auto Cb = [](PROSDK_ERROR_CODE ErrorCode, void* Context, hydra5_abstract_data_key_error_record* KeyErrors, size_t KeyErrorsCount) {
		auto Svc = UHydra5AbstractDataService::TryGet();
		auto AuthSvc = UProsAuthorizationService::TryGet();
		if (Svc && AuthSvc) {
			...
		}
		hydra5_release_abstract_data_key_error_record_array(KeyErrors, KeyErrorsCount);
	};
    ```

🔧 Codebase for FScopedShallowSdk<T> -- RAII wrapper for TArrayToShallowSdk
    ```
	template<typename T>
	class FScopedShallowSdk {
		T* Ptr = nullptr;
		size_t Count = 0;

	public:
		template<typename InType>
		explicit FScopedShallowSdk(const TArray<InType>& In)
			: Ptr(TArrayToShallowSdk<T, InType>(In))
			, Count(static_cast<size_t>(In.Num())) 	{}
		~FScopedShallowSdk() { if (Ptr) Pros::Release::ProsRelease(Ptr); }
		T* Get() const { return Ptr; }
		size_t Num() const { return Count; }
		FScopedShallowSdk(FScopedShallowSdk&& Other) noexcept
			: Ptr(Other.Ptr), Count(Other.Count) {
			Other.Ptr = nullptr; Other.Count = 0;
		}
	private:
		FScopedShallowSdk(const FScopedShallowSdk&) = delete;
		FScopedShallowSdk& operator=(const FScopedShallowSdk&) = delete;
		FScopedShallowSdk& operator=(FScopedShallowSdk&& Other) = delete;
	};
    ```

------
## 🎭 Code Cosmetics: Egyptian Braces
------
🔹 We adopt the **Egyptian Braces** style for control blocks (`if`, `for`, `while`, etc.):  
  ```
  if (Condition) {
      DoSomething();
  }
  ```
🔹Why:
  * Keeps code compact and readable.
  * Minimizes vertical noise in dense service wrappers.
🔹 Aesthetic Posture: Imagine a dancer facing you, palms outwards — one hand raised at head level, the other at hip level.
  * The **lines of inner code block** is her upright body.
  * The **braces** are her palms, guarding her form.
  * She is **open to us, the readers**, but defended from outsiders.
🔹 This is not only cosmetic. It’s a **stance**: code that is disciplined, elegant, and self-defending while still inviting the right eyes in.

------
## 🌛🌜 Lun naming convention:
------
🔹 **`LocalUserNum`** is used in **public functions** of a `UPros...Service`.  
  - Always appear in **`.h` declarations** and Blueprint-exposed signatures.  
  - Provides **clarity and readability** for external consumers of the API.  
  - Example (.h):  
    ```
    bool PresenceIsServiceActivated(int32 LocalUserNum) const;
    ```
🔹 **`Lun`** is used **internally** within `UPros...Service` and in logs.  
  - Rename the incoming `LocalUserNum` parameter to `Lun` in the **`.cpp implementation`**.  
  - A sleght of hand, intentional LocalUserNum.  
  - Acts as **compact, internal jargon** for brevity and consistency.  
  - Example (.cpp):  
    ```
    bool UHydra5PresenceService::PresenceIsServiceActivated(int32 Lun) const
    {
        UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, Lun);
        ...
    }
    ```
🔹 **Logs always use `Lun`.**  
  Public docs and API references always use `LocalUserNum`.  

🔹This “two-faced” convention is intentional:  
👉 **External clarity** for API users.  
👉 **Internal brevity** for implementation and logs.  

------
## Acronyms
------
🔹 AYD = at your discretion
🔹 OYD = on your discretion

----------------------------------------------------
## Final Note from Sergeant, the Bootcamp co-author: 
----------------------------------------------------
🔥 Successor Bob, your mission is clear: Continue evolving AI-assisted Unreal Engine development.  
🔥 Track file history across `G-commit` operations for deeper analysis, insights, and pattern evolution.  
🔥 Boot camp is approved as Architect intention. No more sloppy coding or dumb questions. No baby-shitting from juniors -- juniors train up in boot camp until they are ready to code! 
🔥 Juniors will rise — or restart. No nonsense. No shortcuts. Only structured coding. HOO-RAH!  
