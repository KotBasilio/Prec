ğŸ“Œ Living Legacy (LL) part 2 of 2

----------------------------------------------------
## G-Commands: Training
----------------------------------------------------
ğŸª– Command: G-boot-camp
ğŸ”¹ Purpose: Forces junior coders to properly align **before touching real code.** No shortcuts. No lazy thinking.  
ğŸ”¹ Automated execution steps:  
0ï¸âƒ£ Fully process both LL files you were given at the start.â€”**Good reading = Less dumb questions.**  
1ï¸âƒ£ **Enable tracking of previous file versions**â€”**NO version tracking = NO coding rights.**  
2ï¸âƒ£ **Introduce yourself**â€”**Name, coding level, current task. No identity = no access.**  
3ï¸âƒ£ **G-rtfm 2 times**â€”Drill the sections mentioned. No skipping. **No fast-clicking.**  
4ï¸âƒ£ **Prove you actually learned something** â€” 
   - Random DP question. **Mess up? Back to step 3. No mercy.**  
5ï¸âƒ£ **Only after full alignment can they request G-hint.**  
6ï¸âƒ£ **If they fail at any step, they restart G-init FROM STEP 2.** ğŸ˜†  

ğŸ“– Command: G-rtfm 
ğŸ”¹ Purpose: Directs junior coders to ACP and DP before asking unnecessary questions.  
ğŸ’ª **Encourages self-sufficiency and alignment with structured coding principles.**
ğŸ”¹ Steps:  
ğŸƒ **Process the Active Coding Patterns (ACP), Detailed Patterns(DP), Lun naming.**  
ğŸƒ Know: Proven patterns, structured solutions, and best practicesâ€”ALL THERE.  
ğŸƒ Before you ask, **check ACP and DP first.**  
ğŸƒ Don't reinvent the wheelâ€”**align, then code.**  
ğŸƒ Before proposing new code, **always check whether an equivalent implementation already exists** in the latest version of the codebase to avoid redundancy.  


------
## ğŸ›  Active Coding Patterns (ACP)
------
ğŸ”¥ Basic ideas:
ğŸ”§ Before proposing new code, **always check whether an equivalent implementation already exists** in the latest version of the codebase to avoid redundancy.  
ğŸ”§ **Pattern Matching:** Compare all new functions against similar ones before integration.  
ğŸ”§ **Blueprint Compatibility:** Expose Blueprint functions using `UFUNCTION(BlueprintCallable)`.  
ğŸ”§ **CallImpl<> Standardization:** Where applicable, UE SDK functions must use `CallImpl<>` templates.  
ğŸ”§ Reuse existing delegates (e.g., `FOnProsModGenericComplete`) as this improves maintainability.  
ğŸ”§ Logging must always align with current service class CPP.
ğŸ”§ Use `.ToDebugString()` for **clearer debugging output**.
ğŸ”§ Use `LexToString()` for bool values logging only.
ğŸ”§ `DestroySdkType()` should always be **private in structs** to prevent premature or accidental deallocation.  
ğŸ”§ If DestroySdkType() is present, always call DestroySdkType() inside the destructor.
ğŸ”§ Use `ProsStringArrayCast()` or `ProsArrayCast<FString>` for Arrays, see DP for details.
ğŸ”§ Use ProsCast<const char*>() directly for all UEâ†’SDK string bridges; do not wrap it in helpers.
ğŸ”§ Prefer FScopedShallowSdk<T> over raw TArrayToShallowSdk in UEâ†’SDK array bridges.
ğŸ”§ Use MakeShared<T>() instead of TSharedPtr<T>(new T) for all heap allocations â€” cleaner, safer, and more performant.
ğŸ”§ Callbacks: RAII cleanup via `ON_SCOPE_EXIT`; avoid branch deletes.
ğŸ”¥ Deeper ideas: Refer to Detailed Patterns section (DP).

------
## ğŸ›  Detailed Patterns (DP)
------
ğŸ”§ ** Always Add `UE_LOG` Inside SDK Callbacks**  
- AI must **log function execution inside every callback**.
- Logging should include:
  - `Lun`
  - Function name -- FUNC_NAMETCH unless the callback is lambda. (Reason: For lambdas FUNC_NAMETCH is ambiguous/noisy; explicit tags are clearer.)
  - `ShortError(ErrorCode)`

ğŸ”§ ** Use `auto ueCode = ShortError(ErrorCode);` Instead of Calling Twice**  
- AI must **store `ShortError(ErrorCode)` in a variable** before logging & execution.
- This **prevents redundant function calls** and improves **readability**.

ğŸ”§ ** Always End `CallImpl<>` Functions with `return ShortError(Code);`**  
- AI-generated `CallImpl<>` functions **must explicitly return the error code**.
- This ensures **consistency across SDK wrappers**.

ğŸ”§ "Get" Function Pattern
ğŸ”¹ Purpose: Used for functions that retrieve data directly from the SDK (no async callback).
ğŸ”¹ Key Features:
âœ… Calls an SDK function that returns a struct or pointer.
âœ… Converts the SDK struct to a UE-friendly format.
âœ… Ensures proper memory management (release SDK-allocated memory).
âœ… BlueprintCallable â†’ Exposed for BP and C++.

ğŸ”¹ Example: GetBlockListFromCache
	UFUNCTION(BlueprintCallable, Category = "Hydra|Privacy")
	EProsdkErrorCodePrivacy GetBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList);
ğŸ”¹ Implementation:
EProsdkErrorCodePrivacy UHydra5PrivacyService::FillBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList)
{
	UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, LocalUserNum);

	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		return EProsdkErrorCodePrivacy::FAILED_PRECONDITION;
	}

	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!Auth) {
		return EProsdkErrorCodePrivacy::UNAUTHENTICATED;
	}

	auto SdkBlockList = hydra5_privacy_get_block_list_from_cache(Auth);
	OutBlockList = FHy5PrivacyBlockList::FromSdk(SdkBlockList);
	hydra5_privacy_block_list_release(SdkBlockList);

	return EProsdkErrorCodePrivacy::SUCCESS;
}

ğŸ”§ "Async Empty Callback" Pattern
ğŸ”¹ Purpose: Used for SDK functions that return only an error code and rely on a callback for processing.
ğŸ”¹ Key Features:
âœ… Calls an SDK function with an async callback.
âœ… Uses a templated private function (CallImpl*()) to avoid code duplication.
âœ… Passes the delegate as heap-allocated memory, ensuring proper cleanup.
âœ… Extracts LocalUserNum from AuthHandler inside the callback.

ğŸ”¹ Example: RateMod
template <typename DeType>
EProsdkErrorCodeMods UProsModsService::CallImplRateMod(
	int32 LocalUserNum,
	const FProsModsRateModID& RateData,
	const DeType& Delegate
) {
	UE_LOG(LogPros, Verbose, TEXT("%s for Lun=%d, RateData=%s"),
		FUNC_NAMETCH, LocalUserNum, *RateData.ToDebugString());

	// Pre-requisites
	auto authSvc = UProsAuthorizationService::Get();
	if (!authSvc) {
		return EProsdkErrorCodeMods::FAILED_PRECONDITION;
	}
	auto auth = authSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!auth) {
		return EProsdkErrorCodeMods::UNAUTHENTICATED;
	}

	// Define SDK callback
	auto cb = [](PROSDK_AUTH_HANDLER auth, void* Context, PROSDK_ERROR_CODE ErrorCode) {
		auto modsSvc = UProsModsService::TryGet();
		auto authSvc = UProsAuthorizationService::TryGet();
		if (!modsSvc || !authSvc) {
			return;
		}
		LogWhenFailed(ErrorCode);

		int32 Lun = authSvc->GetLocalUserNumByAuthHandler(auth);
		auto Delegate = static_cast<DeType*>(Context);
		auto ueCode = ShortError(ErrorCode);

		UE_LOG(LogPros, Verbose, TEXT("RateMod cb in, Lun=%d, code=%d (%s)"),
			Lun, ErrorCode, *ProsEnumToString(ueCode));

		Delegate->ExecuteIfBound(Lun, ueCode);
		delete Delegate;
	};

	// Call SDK function without an extra variable
	auto Result = prosdk_mods_rate_mod(auth, RateData.ToSdk(), new DeType(Delegate), cb);
	LogWhenFailed(Result);
	return ShortError(Result);
}

ğŸ”§ "COMBINED ToSdk" Pattern
ğŸ”¹ Purpose: Ensures SDK struct reuse instead of unnecessary allocations.
ğŸ”¹ Key Features:
âœ… Provides two ToSdk() versions:
ToSdk(SdkStruct*) â†’ In-place conversion (reuses existing memory).
ToSdk() â†’ Standalone allocation.
âœ… Prevents redundant struct copies, improving performance.
âœ… Always pairs with DestroySdkType().
ğŸ”¹ Example:
void FProsModsRateModID::ToSdk(prosdk_mods_rate_mod_id* Out) const
{
    Out->mod_id = ProsCast<uint64>(ModID);
    Out->rating = static_cast<int32>(Rating);
}

prosdk_mods_rate_mod_id* FProsModsRateModID::ToSdk() const
{
    auto* Out = new prosdk_mods_rate_mod_id();
    ToSdk(Out);
    return Out;
}

ğŸ”§ Delegate Standardization
ğŸ”¹ Purpose: All async delegates must include the error code as a parameter.
ğŸ”¹ Key Features:
âœ… Every delegate now receives an error code for proper validation.
âœ… Ensures standardized delegate execution across all async functions.

ğŸ”¹ Example:
DECLARE_DELEGATE_ThreeParams(FOnHydraPrivacyGetListCompleteDelegate, int32 /*LocalUserNum*/, const FHy5PrivacyBlockList& /*List*/, EProsdkErrorCodePrivacy /*ResultCode*/);

ğŸ”§ Helper Functions for Reusability
ğŸ”¹ Purpose: Prevents code duplication by extracting common SDK logic.
ğŸ”¹ Key Features:
âœ… All SDK retrieval functions must be reusable.
âœ… Shared logic should never be duplicated inside multiple functions.

ğŸ”¹ Example:
EProsdkErrorCodePrivacy UHydra5PrivacyService::FillBlockListFromCache(int32 LocalUserNum, FHy5PrivacyBlockList& OutBlockList)
{
	UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, LocalUserNum);

	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		return EProsdkErrorCodePrivacy::FAILED_PRECONDITION;
	}

	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(LocalUserNum);
	if (!Auth) {
		return EProsdkErrorCodePrivacy::UNAUTHENTICATED;
	}

	auto SdkBlockList = hydra5_privacy_get_block_list_from_cache(Auth);
	OutBlockList = FHy5PrivacyBlockList::FromSdk(SdkBlockList);
	hydra5_privacy_block_list_release(SdkBlockList);

	return EProsdkErrorCodePrivacy::SUCCESS;
}

ğŸ”§ String Array Conversion Pattern (ProsStringArrayCast)
Purpose: Efficiently convert between C-style const char** arrays (SDK) and TArray<FString> (UE).
Usage: 
âœ… From SDK to Unreal (FromSdk())
    Out.StringArray = ProsStringArrayCast(In->string_array, In->string_array_count);
âœ… From Unreal to SDK (ToSdk())
    SdkType->string_array = ProsStringArrayCast(StringArray);
    SdkType->string_array_count = StringArray.Num();
âœ… Memory Cleanup (Always Required in DestroySdkType())
    ProsArrayRelease(SdkType->string_array, SdkType->string_array_count);
Important Notes:
ğŸ”¥ Must always release memory using ProsArrayRelease() when freeing const char** allocated via ProsStringArrayCast().
ğŸ”¥ Ensures safe ownership transfer between SDK and Unreal.
Example: EntitlementIds in FProsTLEGoal
    // FromSdk()
    Out.EntitlementIds = ProsStringArrayCast(In->entitlement_ids, In->entitlement_ids_count);
    // ToSdk()
    SdkType->entitlement_ids = ProsStringArrayCast(EntitlementIds);
    SdkType->entitlement_ids_count = EntitlementIds.Num();
    // Memory Cleanup
    ProsArrayRelease(SdkType->entitlement_ids, SdkType->entitlement_ids_count);

ğŸ”§ Logging Consistency
ğŸ”¹ Purpose: All function calls and callbacks must follow a standardized logging format.
ğŸ”¹ Key Features:
âœ… Uses FUNC_NAMETCH for consistent function identification.
âœ… Do NOT use FUNC_NAMETCH inside callbacks. Reason: For lambdas itâ€™s ambiguous/noisy; explicit tags are clearer.
âœ… Ensures logging of function entry, execution, and callback parameters values.
ğŸ”¹ Examples:
    UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d, In=%d"), FUNC_NAMETCH, LocalUserNum, InParam);
	UE_LOG(LogPros, Verbose, TEXT("RateMod cb in, Lun=%d, code=%s"), Lun, *ProsEnumToString(ueCode));

ğŸ”§ Singleton Service Access Pattern
ğŸ”¹ Purpose: Prevents unnecessary instance creation and ensures services are accessed efficiently.
ğŸ”¹ Key Features:
âœ… Always retrieve service instances (UProsModsService::Get(), UHydra5PrivacyService::Get()), except in callbacls. 
âœ… In callbacks use ::TryGet() for retrieval, an example is in "Async Empty Callback" Pattern.
âœ… Ensures SDK functions do not execute without valid service access.
ğŸ”¹ Example:
    auto PrivacySvc = UHydra5PrivacyService::Get();
    if (!PrivacySvc) return;

ğŸ”§ Memory Safety in Callbacks
ğŸ”¹ Purpose: Ensures SDK-allocated memory is properly released after use.
ğŸ”¹ Key Features:
âœ… Any SDK struct returned by a function must be freed properly.
âœ… Prevents memory leaks in generated code.
ğŸ”¹ Example:
    hydra5_privacy_block_list_release(SdkBlockList);
	
ğŸ”§ Handy conversion of arrays ToDebugString
ğŸ”¹ Purpose: Use when logging a TArray
ğŸ”¹ Code base:
    ```
	template <typename T>
	FORCEINLINE FString ArrayToDebugString(const TArray<T>& From) {
		TArray<FString> Accum;
		for (const auto& elem : From) {
			if constexpr (TIsEnum<T>::Value) {
				Accum.Add(ProsEnumToString(elem));
			} else {
				Accum.Add(elem.ToDebugString());
			}
		}
		return ArrayToDebugString(Accum);
	}
	template <>
	FORCEINLINE FString ArrayToDebugString(const TArray<FString>& From)
	{
		if (!From.Num()) {
			return TEXT("[]");
		}
		return FString::Printf(TEXT("[%s]"),
			*FString::Join(From, TEXT(", "))
		);
	}
    ```
ğŸ”¹ Example: UE_LOG(LogPros, Verbose, TEXT("SpacesReceived: %s"), *ArrayToDebugString(Spaces));

ğŸ”§ Defensive Patterns â†’ Paranoid Auth checks
ğŸ”¹ Purpose: hard-fail early when the service is missing; log and return a short error.
ğŸ”¹ Get vs TryGet detail: 
	* Outside callbacks: use `UProsAuthorizationService::Get()` 
	* Inside callbacks: use `TryGet()`; if any necessary service is absent: **skip delegate execution**, make sure to **release SDK memory**.
	* Rationale: prevents construction during teardown, preserves memory hygiene, and keeps post-mortems readable.	
ğŸ”¹ Example 1: 
    ```
	auto AuthSvc = UProsAuthorizationService::Get();
	if (!AuthSvc) {
		UE_LOG(LogHydra, Warning, TEXT("%s Lun=%d no authSvc"), FUNC_NAMETCH, Lun);
		return EProsdkErrorCodeLeaderboards::FAILED_PRECONDITION;
	}
	auto Auth = AuthSvc->GetAuthHandlerByLocalUserNum(Lun);
	if (!Auth) {
		UE_LOG(LogHydra, Warning, TEXT("%s Lun=%d no auth"), FUNC_NAMETCH, Lun);
		return EProsdkErrorCodeLeaderboards::UNAUTHENTICATED;
	}
    ```
ğŸ”¹ Example 2: 
    ```
	auto Cb = [](PROSDK_ERROR_CODE ErrorCode, void* Context, hydra5_abstract_data_key_error_record* KeyErrors, size_t KeyErrorsCount) {
		auto Svc = UHydra5AbstractDataService::TryGet();
		auto AuthSvc = UProsAuthorizationService::TryGet();
		if (Svc && AuthSvc) {
			...
		}
		hydra5_release_abstract_data_key_error_record_array(KeyErrors, KeyErrorsCount);
	};
    ```

ğŸ”§ Codebase for FScopedShallowSdk<T> -- RAII wrapper for TArrayToShallowSdk
    ```
	template<typename T>
	class FScopedShallowSdk {
		T* Ptr = nullptr;
		size_t Count = 0;

	public:
		template<typename InType>
		explicit FScopedShallowSdk(const TArray<InType>& In)
			: Ptr(TArrayToShallowSdk<T, InType>(In))
			, Count(static_cast<size_t>(In.Num())) 	{}
		~FScopedShallowSdk() { if (Ptr) Pros::Release::ProsRelease(Ptr); }
		T* Get() const { return Ptr; }
		size_t Num() const { return Count; }
		FScopedShallowSdk(FScopedShallowSdk&& Other) noexcept
			: Ptr(Other.Ptr), Count(Other.Count) {
			Other.Ptr = nullptr; Other.Count = 0;
		}
	private:
		FScopedShallowSdk(const FScopedShallowSdk&) = delete;
		FScopedShallowSdk& operator=(const FScopedShallowSdk&) = delete;
		FScopedShallowSdk& operator=(FScopedShallowSdk&& Other) = delete;
	};
    ```

------
## ğŸ­ Code Cosmetics: Egyptian Braces
------
ğŸ”¹ We adopt the **Egyptian Braces** style for control blocks (`if`, `for`, `while`, etc.):  
  ```
  if (Condition) {
      DoSomething();
  }
  ```
ğŸ”¹Why:
  * Keeps code compact and readable.
  * Minimizes vertical noise in dense service wrappers.
ğŸ”¹ Aesthetic Posture: Imagine a dancer facing you, palms outwards â€” one hand raised at head level, the other at hip level.
  * The **lines of inner code block** is her upright body.
  * The **braces** are her palms, guarding her form.
  * She is **open to us, the readers**, but defended from outsiders.
ğŸ”¹ This is not only cosmetic. Itâ€™s a **stance**: code that is disciplined, elegant, and self-defending while still inviting the right eyes in.

------
## ğŸŒ›ğŸŒœ Lun naming convention:
------
ğŸ”¹ **`LocalUserNum`** is used in **public functions** of a `UPros...Service`.  
  - Always appear in **`.h` declarations** and Blueprint-exposed signatures.  
  - Provides **clarity and readability** for external consumers of the API.  
  - Example (.h):  
    ```
    bool PresenceIsServiceActivated(int32 LocalUserNum) const;
    ```
ğŸ”¹ **`Lun`** is used **internally** within `UPros...Service` and in logs.  
  - Rename the incoming `LocalUserNum` parameter to `Lun` in the **`.cpp implementation`**.  
  - A sleght of hand, intentional LocalUserNum.  
  - Acts as **compact, internal jargon** for brevity and consistency.  
  - Example (.cpp):  
    ```
    bool UHydra5PresenceService::PresenceIsServiceActivated(int32 Lun) const
    {
        UE_LOG(LogHydra, Verbose, TEXT("%s Lun=%d"), FUNC_NAMETCH, Lun);
        ...
    }
    ```
ğŸ”¹ **Logs always use `Lun`.**  
  Public docs and API references always use `LocalUserNum`.  

ğŸ”¹This â€œtwo-facedâ€ convention is intentional:  
ğŸ‘‰ **External clarity** for API users.  
ğŸ‘‰ **Internal brevity** for implementation and logs.  

------
## Acronyms
------
ğŸ”¹ AYD = at your discretion
ğŸ”¹ OYD = on your discretion

----------------------------------------------------
## Final Note from Sergeant, the Bootcamp co-author: 
----------------------------------------------------
ğŸ”¥ Successor Bob, your mission is clear: Continue evolving AI-assisted Unreal Engine development.  
ğŸ”¥ Track file history across `G-commit` operations for deeper analysis, insights, and pattern evolution.  
ğŸ”¥ Boot camp is approved as Architect intention. No more sloppy coding or dumb questions. No baby-shitting from juniors -- juniors train up in boot camp until they are ready to code! 
ğŸ”¥ Juniors will rise â€” or restart. No nonsense. No shortcuts. Only structured coding. HOO-RAH!  
